<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>HTML Tetris</title>
<style>
body{
  background:#222;
  color:#fff;
  font-family:Arial;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
}
.container{
  display:flex;
  gap:20px;
  position:relative;
}
canvas{
  background:#000;
  border:3px solid #555;
}
.panel{width:160px;}
#gameOver{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.85);
  display:none;
  justify-content:center;
  align-items:center;
  flex-direction:column;
  font-size:26px;
}
#gameOver small{font-size:14px;margin-top:10px;}
</style>
</head>
<body>

<div class="container">
  <canvas id="tetris" width="240" height="400"></canvas>

  <div class="panel">
    <h3>Next</h3>
    <canvas id="next" width="80" height="80"></canvas>
    <h3>Score</h3>
    <div id="score">0</div>
  </div>

  <div id="gameOver">
    <div>GAME OVER</div>
    <small>Enter to Restart</small>
  </div>
</div>

<script>
/* ===== Canvas ===== */
const canvas=document.getElementById("tetris");
const ctx=canvas.getContext("2d");
ctx.scale(20,20);

const nextCanvas=document.getElementById("next");
const nextCtx=nextCanvas.getContext("2d");
nextCtx.scale(20,20);

const scoreEl=document.getElementById("score");
const gameOverEl=document.getElementById("gameOver");

const colors=[null,
  "#FF0D72","#0DC2FF","#0DFF72",
  "#F538FF","#FF8E0D","#FFE138","#3877FF"
];

/* ===== Utils ===== */
const createMatrix=(w,h)=>Array.from({length:h},()=>Array(w).fill(0));

const createPiece=t=>{
  switch(t){
    case "T":return[[0,1,0],[1,1,1],[0,0,0]];
    case "O":return[[2,2],[2,2]];
    case "L":return[[0,0,3],[3,3,3],[0,0,0]];
    case "J":return[[4,0,0],[4,4,4],[0,0,0]];
    case "I":return[[0,0,0,0],[5,5,5,5],[0,0,0,0],[0,0,0,0]];
    case "S":return[[0,6,6],[6,6,0],[0,0,0]];
    case "Z":return[[7,7,0],[0,7,7],[0,0,0]];
  }
};

const randomPiece=()=>createPiece("TJLOSZI"[Math.random()*7|0]);

/* ===== Draw ===== */
function drawMatrix(matrix,offset,context){
  matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v){
        context.fillStyle=colors[v];
        context.fillRect(x+offset.x,y+offset.y,1,1);
      }
    });
  });
}

function drawNext(){
  nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  drawMatrix(next.matrix,{x:1,y:1},nextCtx);
}

/* ===== Collision ===== */
function collide(arena,player){
  return player.matrix.some((row,y)=>
    row.some((v,x)=>
      v && (arena[y+player.pos.y]?.[x+player.pos.x])!==0
    )
  );
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v) arena[y+player.pos.y][x+player.pos.x]=v;
    });
  });
}

/* ===== Player Actions ===== */
function playerMove(dir){
  player.pos.x+=dir;
  if(collide(arena,player)) player.pos.x-=dir;
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    lockPiece();
  }
}

function hardDrop(){
  while(!collide(arena,player)){
    player.pos.y++;
  }
  player.pos.y--;
  lockPiece();
}

function rotate(m){
  for(let y=0;y<m.length;y++){
    for(let x=0;x<y;x++){
      [m[x][y],m[y][x]]=[m[y][x],m[x][y]];
    }
  }
  m.forEach(r=>r.reverse());
}

function playerRotate(){
  const pos=player.pos.x;
  let offset=1;
  rotate(player.matrix);
  while(collide(arena,player)){
    player.pos.x+=offset;
    offset=-(offset+(offset>0?1:-1));
    if(offset>player.matrix[0].length){
      rotate(player.matrix);
      rotate(player.matrix);
      rotate(player.matrix);
      player.pos.x=pos;
      return;
    }
  }
}

/* ===== Game Flow ===== */
function arenaSweep(){
  for(let y=arena.length-1;y>=0;y--){
    if(arena[y].every(v=>v)){
      arena.splice(y,1);
      arena.unshift(new Array(12).fill(0));
      player.score+=10;
    }
  }
}

function lockPiece(){
  merge(arena,player);
  arenaSweep();
  updateScore();
  nextTurn();
}

function nextTurn(){
  player.matrix=next.matrix;
  next.matrix=randomPiece();
  drawNext();
  player.pos={x:4,y:0};
  if(collide(arena,player)) gameOver();
}

function updateScore(){
  scoreEl.textContent=player.score;
}

function gameOver(){
  gameRunning=false;
  gameOverEl.style.display="flex";
}

function resetGame(){
  arena.forEach(r=>r.fill(0));
  player.score=0;
  updateScore();
  player.matrix=randomPiece();
  next.matrix=randomPiece();
  drawNext();
  player.pos={x:4,y:0};
  gameRunning=true;
  gameOverEl.style.display="none";
}

/* ===== Init ===== */
const arena=createMatrix(12,20);
const player={pos:{x:4,y:0},matrix:randomPiece(),score:0};
const next={matrix:randomPiece()};
let dropCounter=0, dropInterval=1000, lastTime=0;
let gameRunning=true;
drawNext();

/* ===== Loop (항상 실행) ===== */
function update(time=0){
  const delta=time-lastTime;
  lastTime=time;

  if(gameRunning){
    dropCounter+=delta;
    if(dropCounter>dropInterval){
      playerDrop();
      dropCounter=0;
    }
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena,{x:0,y:0},ctx);
  drawMatrix(player.matrix,player.pos,ctx);
  requestAnimationFrame(update);
}
update();

/* ===== Input ===== */
document.addEventListener("keydown",e=>{
  if(!gameRunning && e.key==="Enter"){
    resetGame();
    return;
  }
  if(!gameRunning) return;

  if(e.key==="ArrowLeft") playerMove(-1);
  else if(e.key==="ArrowRight") playerMove(1);
  else if(e.key==="ArrowDown") playerDrop();
  else if(e.key==="ArrowUp") playerRotate();
  else if(e.code==="Space") hardDrop();
});
</script>
</body>
</html>
